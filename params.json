{"body":"# Introduction\r\n\r\n## What is the _TipTap_ library?\r\n\r\nThe _TipTap_ library is a javascript library to ease mouse and touch complex gestures definition and management on HTML\r\nDOM elements (so, though not tested, on SVG and Canvas too), as well as to provide a unified way of managing different\r\ninput devices systems: mouse, touch systems and their specific data structure (iOS, Android, Windows...), Leap Motion\r\nhopefully, etc. In fact, it's mostly a present & future based library, mostly aimed at multi-pointers interactivity,\r\ninstead of our old-fashioned and already outdated mouse. But it of course supports mouse!\r\n\r\nThis library was meant to fill a hole that I couldn't fill immediately with any other initiative around here,\r\nsee [this page](https://github.com/bebraw/jswiki/wiki/Touch) for a quite comprehensive list of touch libs around. See\r\nit as a mix between [Hammer.js](http://eightmedia.github.com/hammer.js/), [Touchy](https://github.com/HotStudio/touchy),\r\n[Dojox.gesture](http://dojotoolkit.org/reference-guide/1.7/dojox/gesture.html#dojox-gesture), and coming from the same\r\nstatement as done by Boris Smus about \"broken\" touch events in browsers, leading him to create his\r\n[pointers](http://smus.com/mouse-touch-pointer/) library. You could see TipTap as a more complete version of \"pointers\",\r\nexcept that Mr Smus codes much better than me :-D\r\n\r\n# License\r\n\r\nLet's give back to a community who gives me so much: [MIT License](http://www.opensource.org/licenses/mit-license.php)\r\n\r\n# The TipTap library\r\n\r\n## So, was it meant to do?\r\n\r\nEssentially, its goal is to:\r\n* provide a unified, input-device agnostic events capturing system: dealing with Mouse, Touch, Augmented Gestures\r\n(see [Jérôme Etienne's work](https://github.com/jeromeetienne/augmentedgesture.js)), Leap Motion, etc.\r\n* compensate for human lack of accuracy, leading to almost-simultaneous actions of fingers, instead of simultaneous.\r\nThink of double bi-tap for example, chances are that you will not tap both fingers twice exactly simultaneously.\r\nEven if you do, you will not always. And now, try with tri-tap, or worse, double tri-swipe! This inaccuracy was one of\r\nthe main reason to create this lib, and by far the biggest technical issue to solve. To do this, when a pointer event\r\noccurs, it will wait for a tiny amount of time to see if other similar events come. If it happens, it will group the\r\nevent together, a bit like what is done natively by iOS with its touch events and the touches* arrays.\r\n* despite the previous step, not miss any event! \r\n* differenciate simply between tap, tip (long tap), swipe, move, pinch, spread, rotate...\r\n* give a rich but simple language to define complex gestures, in an Event-like syntax. Example:\r\n\t$('#element').jTiptap ('on', 'tap', <callback>);\r\n\tallowing gestures like: double two fingers tap, double finger tip plus simultaneous swipe, etc.\r\n* allow attachment of such listeners to several elements in the same page\r\n* allow attachment of several such listeners to a same element\r\n* allow delegation, attaching to a parent element, with a filter to define which children it applies. As you would expect,\r\n\tit lets you attach the callback to a container in which elements will be added dynamically\r\n\r\n\r\n## Dependencies\r\n\r\nThe library currently relies on:\r\n- [jQuery](http://jquery.com/) (1.7.2+)\r\n- [Underscore](http://underscorejs.org) by Jeremy Ashkenas, or [Lodash](https://github.com/bestiejs/lodash) by John-David Dalton\r\n- [Signals](http://millermedeiros.github.com/js-signals/) by Miller Medeiros\r\n\r\nI would love to have no dependency at all, but...\r\n\r\n\r\n## Current status\r\n\r\nCurrently, the library is usable, but is still missing few things, which doesn't make it suitable for immediate production\r\nuse. However, it gives curious people (or people in the need for such a lib) the ability to start playing with it and give\r\nfeedback (mommy I'm scared!). Known missing points:\r\n* real (usable) handling of rotation and zoom\r\n* cleaner/better coding, like using the Markus Gundersen's work-(strongly) inspired rotation-zoomer class as a plugin\r\n* identify a gesture by the proximity of the pointers: it will prevent two almost simultaneous taps at both ends of the\r\nsurface to be considered as a same gesture, which is in general never the case. Will be even more important on large\r\ninteraction surface like Microsoft Surface tables\r\n* give ability to the application using the lib to split a gesture into several ones\r\n* making it more a module than a plugin (see Miller Medeiros' articles about this), and have jQuery pluginification as\r\n\ta plus (it's more or less done, but not great)\r\n* unit tests: I need to take a deep dive into this, and didn't have the time (courage?) to do it yet\r\n* making it both script-tag and AMD-compatible (I shamefully failed to do this)\r\n\r\nConsider this as a something like a 0.4 release, not ready for production.\r\n\r\n\r\n# The elements\r\n\r\nAll gestures and combos are defined for a DOM element. I didn't use Events for this, but a simple callback system.\r\n(Should it be reworked as Events? **Feedback welcome**) You can define gestures and combos for an element, or for its\r\ndescendants, by using a selector string (for now, because of the use of jQuery, this selector can be complex, but if I\r\nremove this dependency, I think I would have to go to simpler things like class or id matching, wouldn't I?)\r\n\r\n\r\n# The gestures\r\n\r\n\r\n## Simple gestures supported\r\n\r\n\r\n### Normal gestures\r\n\r\nThe basic gestures supported by the library are the ones you expect (don't deny, I know it!). I'll use the vocabulary of\r\na touch screen to define the movements to be done:\r\n- _tap_: you touch briefly the sensitive surface, and remove your finger almost instantly. Like a mouse _click_.\r\n- _tip_: you touch the sensitive surface, and stay on it. Like a mouse _down_.\r\n- _swipe_: it's like a fast-moving tap. You move the finger fast in one direction (top, right, bottom or left) and while\r\n\tmoving fast, you tap the screen. Your finger draws a \"U\" in the air, tangenting the screen at the bottom of the curve,\r\n\tgently (but quickly and briefly, after all, I said \"tangenting\") gliding on it. Of course, the library corrects any not\r\n\tperfect direction, and keeps the direction of the biggest movement\r\n- _rotate_: current managing of rotation is not nice. I mean, I quickly hacked a modified version of Markus Gundersen\r\n\ttouch demo, to allow for zoom and rotate. But it's not yet as efficient as was my previous implementation, and I have\r\n\tto merge both. Rotation can be done with two or three (or more, but well..) fingers down, and we'll see why it matters.\r\n- _pinch_: aka _zoom_, it's, well allowing you to do what you expect. Same comment as for rotate: count of fingers may\r\n\tdiffer, and this can be used efficiently.\r\n- _drag_: it's simply moving a pointer while _tipping_\r\n- _move_: **not yet implemented**, but should probably be in the future. It's moving without tipping. Impossible on a\r\n\ttouchscreen, but for a mouse, and for other devices, it is.\r\n\r\n\r\n### Notification gestures\r\n\r\nIn addition to these \"real\" gestures, exist few \"notification\" gestures. Complete understanding of such gestures comes\r\nwith the explanation of combos. The notification gestures are the following:\r\n- _press_: fired when a finger touches the screen (_touchstart_ event), a mouse is pressed, etc.\r\n- _started_dragging_: fired when a finger starts moving, a mouse with button pressed starts moving, etc.\r\n- _stopped_dragging_: fired when a finger IS RELEASED FROM THE SCREEN after some dragging, a mouse with button is\r\nreleased after it was dragged, etc. Whether I should implement a timer to detect the end of the motion is not decided\r\nyet (sounds cool and logical, but maybe difficult, so, as usual, **feedback welcome**)\r\n- _release_: as expected, fired when fingers are removed from the screen (mouse released, etc.)\r\n\r\nSee below for explanation of the [difference between normal simple gestures and notification gestures](#1).\r\n\r\n\r\n## Combining simple gestures on multi-pointers devices\r\n\r\nIf it was only for simple gestures, this lib wouldn't be very useful, since lots of others do this quite well (Hammer.js,\r\nTouchy, etc.) It's main interest lies in the ability to create complex gestures (and [_combos_](#2)). A complex gesture\r\nis defined by several simple gestures happening simultaneously:\r\nFew examples:\r\n- bi-tap\r\n- tri-tap\r\n- tip **and** swipe: one pointer is tipping, while the other is swiping\r\n- bi-tip\r\n- etc.\r\n\r\n\r\n<a name=\"2\" />\r\n## Combining gestures in combos\r\n\r\nCombos (as in Street Fighter-like games) are lists of gestures (simple or complex), happening with a short period\r\nof time between each. A combo is ended by any lack of activity during a period of time longer than this accepted\r\nduration for a combo, or by any number of _tips_. Examples of combos:\r\n- double _tap_ then _tip_\r\n- triple _tap_\r\n- double bi-tap: by \"bi-tap\", I mean tapping two pointers at once\r\n- double _tip_ followed by _swipe_: can be a trigger of an action in an application, or a special attack combo in a game\r\n- combinations are almost endless (in fact, no, some decisions had to be taken due to technical constraints, and\r\n\tthe uselessness of the related possibilities), mostly limited by the convenience of the combo (let's say that \"triple\r\n\tquad-tap followed by bi-tap simultaneously with triple-swipe\" wouldn't exactly be a very usable combo :-D)\r\n\r\n\r\n<a name=\"1\" />\r\n## Difference between simple gestures and notification gestures\r\n\r\nGestures that can be part of combos are not sent immediately to the app. Indeed, the goal being to be a \"black-box\"\r\nfor the app using the library, the idea is to not bother the app till we don't have a combo, that we match with\r\ndefinitions of callbacks. So, after a n-tap, for example, the lib wil wait for a few fractions of a second, in case a\r\nnew event is happening, to chain it in a combo. That's of course ok, but if you want to react on mouse press/touchstart,\r\nthis small amount of time to react will appear to the user as an eternity, or, let's say, will make the UI appear as\r\nsluggish. So, the solution is to use what I called \"notification\" gestures. They are sent immediately, and \"in parallel\" of normal gestures, and can't be in combos, that they would pollute. Examples:\r\n- if you touch a screen, move immediately, then release, you will get: press, dragStart, drag (few times),\r\ndragStop, release.\r\n- if you double tap a screen, while a finger is already touching, you will get: tip-press, tip-release, tip-tap. **In this\r\norder**. Remember: tap and swipe being \"combo-able\", they aren't sent right away. That's why release arrives first. This\r\nsaid, it's up to the app to decide which \"event\" to use.\r\n\r\n\r\n## Mono-pointers (mouse) fallbacks\r\n\r\nFor now, there's not exactly any _fallbacks_, in the way that you could magically simulate multi-pointers with mono-pointer\r\nsystem. Sorry. I'm thinking of some key-button combination, like shift-click to place the center of the rotation, then\r\nclick and drag to rotate... feedback welcome!\r\n\r\nSo, what fallbacks mean is that you can define combos which react to both touch or mouse events, simply masking you the\r\ndifference. So, yes, only single pointer interactions can be done with mouse.\r\n\r\n\r\n# Syntax for defining gestures\r\n\r\n## Defining simple gestures\r\n\r\nThe syntax for defining simple gestures is, well, simple:\r\n- the base is simply the gesture name: _tip_, _tap_, _swipe_t_, _swipe_r_, _swipe_b_, _swipe_l_, _pinch_ *, _rotate_ *,\r\n_drag_\r\n- add to this the count of pointers involved. Want to signify a tap of two fingers? _tap2_. A tri-swipe to the right?\r\n_swipe_r3_. Dragging with 2 pointers? _drag2_.\r\n- as the smart readers will have noticed, no need to put \"1\" when only one pointer is involved.\r\n\r\n(*) pinch and rotate are not yet implemented like this in this alpha release. I'm still not decided on whether I should\r\nenhance the object returned to the drag callback with some rotation and zoom values, or define _pinch_ and _rotate_ as\r\ngestures. Indeed, any two (or more) pointers dragging involves some zoom (we are not robots), so either we have a _zoom_ gesture, for which we can define precision-triggering threshold, or we have only _drag_ gesture and values of rotation and zoom, and the application decides what to do with. **Feedback and suggestions welcome**\r\n\r\n\r\n## Defining complex gestures\r\n\r\nAs we saw before, complex gestures are a combination of simultaneous simple gestures. In fact, it's even more reduced\r\nthan this, since you can't really combine _any_ kind of gestures. And it quite makes sense: though we can imagine doing\r\nsome rotation with both hands, chances are that they will happen on different elements, and will as such be defined as\r\ntwo different gestures. What is more realistic is combination of _tips_ and (_taps_ or _swipes_).\r\n\r\n### With \"tip\" prefix\r\nDepending on your usage, you may or not want the lib to use \"tip prefixing\" (see [Settings](#3). By this, I mean include in the complex gestures definition, the \"tip\" count for tipping fingers. Example, if you want to trigger an action for every tap happening while two fingers are tipping, you would use: \"tip2-tap\". This is convenient for some quick application, or some demo, not using any robust routing or finite state machine to deal with complex things. Examples: _tip2-tap2_ (two fingers down, tap with two others), _tip-swipe\\_b_, etc.\r\n\r\n### Without \"tip\" prefix\r\nYou define combos and complex gestures without taking into consideration the count of tipping fingers,\r\nbecause, somehow, you already deal with this with your routing system, FSM, etc. So,\r\nsince you will already know that you are in the state \"tip2\", for example, you just define the combo as _tap2_,\r\nfor dealing with a _tip2-tap2_.\r\n\r\n## Pattern matching\r\n\r\nSometimes, you want to catch a move, whatever the context (translate: whatever count of tips). Some other time, you may\r\nwant to trigger something whatever the count of pointers tapping simultaneously. Etc. In all these cases, you should use\r\na joker, as in regular expressions. And, what a chance, we use the same modifiers as in RegExp!\r\n- __*__: any number of times (== \"0 or more\")\r\n- __+__: any number of times > 0 (== \"1 or more\")\r\n- __?__: 0 or 1 occurrence\r\n\r\nExamples:\r\n- with any count of fingers tipping, act when exactly one is removed: _tip\\*-untip_. (Why _tip\\*_, not _tip+_?\r\nBecause when you untip, the untipped finger is not tipping anymore (brilliant, I know, I know). So, untipping a single\r\nfinger returns only \"untip\", not \"tip-untip\")\r\n- with any count of fingers tipping, act when some new fingers start tipping: tip*-tip+\r\n- etc.\r\n\r\n\r\n## Defining combos\r\n\r\nAs you know, combos being few gestures in a row, we only need a separator between gestures (which is also overloadable,\r\nbut can't be omitted). I went for greater than: \">\"\r\nExamples:\r\n- double tap: tap>tap\r\n- double bi-tap followed by bi-swipe right: tap2>tap2>swipe_r2\r\n- same as above, but requiring that there are first 3 fingers touching the screen: tip3-tap2>tip3-tap2>tip3-swipe_r2\r\n- etc.\r\n\r\n# Callbacks on intersecting combos\r\n\r\nThe library allows to define several callbacks on a same combo, or, let's say, on __intersecting combos__. If it may not\r\nsound useful at first, it's in fact adding a real comfort (and was added for this reason :-p). Let's take the example\r\nof the simple demo. We must catch all the fingers touching each picture, either when tipping, or when touching and moving\r\nright away; for this reason, we catch: __tip\\*-tip+/tip\\*-press+__. However, highlighting the picture ONLY when you\r\nwant it (that is, when you select or drag it) in this callback would be tricky (I know, I tried :-)): if you do so, the\r\n__press__ \"event\" caught means that when you double-tap, the picture will highlight, de-highlight (supposing we have the\r\nsymmetrical logic for de-highlighting), highlight again, de-highlight again. Not nice. Adding the ability to test, within\r\nthe callback, which \"event\" was really caught (if event == \"tip\") is not elegant for the app coder. So instead, you add\r\nanother callback on __tip+/dragStart+__ in which you define the highlight. You'll notice that there's no __tip\\*__,\r\nwhich means we DO want only the first finger action here (for this, it wouldn't hurt to do it at each finger, but it\r\nwould be useless, so why waste CPU cycles?). Similarly, to de-highlight, we catch: __untip+/dragStop+__. This time\r\nhowever, not putting __tip\\*__ is important, because we want to signify that we remove the highlight ONLY when the LAST\r\nfinger(s) is(are) removed.\r\n\r\n\r\n# Coding\r\n\r\n## TipTap initialization\r\nYou must first call TipTap.init(), passing an optional settings object. The list of fields and their default value:\r\n\r\n```javascript\r\ncomboAlternateOperator: \"|\",\r\n```\r\n\r\nChar to define alternate combos: press|tip\r\n\r\n```javascript\r\ncomboEndTimer_ms: 100,\r\n```\r\n\r\nMax delay between two actions in a same combo (like time between two clicks in a double-click)\r\n\r\n```javascript\r\ncomboGesturesSep: \">\",\r\n```\r\n\r\nSeparator of gestures in combos: tap2**>**tap2 (double bi-tap)\r\n\r\n```javascript\r\ncomboParallelActionOperator: \"-\",\r\n```\r\n\r\nSeparator of simple gestures in complex gesture: tip2-tap2 (bi-tap while bi-tipping)\r\n\r\n```javascript\r\ndebug: true\r\n```\r\n\r\nGlobal flag to \"trace\" the code (this and related code should be remove from production use, but quite convenient for understanding what's happening in your gestures)\r\n\r\n```javascript\r\ndeviceType: TipTap.DEVICE_MOUSE,\r\n```\r\n\r\nCan be TipTap.DEVICE_MOUSE or TipTap.DEVICE_TOUCH. If you want to force the type of device on which to work. In practice,\r\nit doesn't make sense to force it, and you should let the library define by itself what type of device to use.\r\n\r\n```javascript\r\nmoveThreshold_px: TipTap.touch ? 8 : 0,\r\n```\r\n\r\nWhen you think your finger is perfectly still on the screen, it's in fact moving, most of the time. This is another tolerance factor.\r\n\r\n```javascript\r\nrotoZoom: false,\r\n```\r\n\r\nGlobal flag to activate or not the rotation and zoom \"demo\" effect. Will be replaced by more specific flag when these effects are correctly implemented.\r\n\r\n```javascript\r\nsimultaneousMovesTimer_ms: 3 * TipTap.TOUCH_REFRESH_ms,\r\n```\r\n\r\nDelay accepted between similar events/moves to be considered as simultaneous. It's one of the key reasons of this library,\r\ncompensating for not perfect simultaneity of fingers tapping for example.\r\n\r\n```javascript\r\nswipeDuration_ms: 8 * TipTap.TOUCH_REFRESH_ms,\r\n```\r\n\r\nLongest move duration to still be considered as a swipe (moving the finger, even fast, all along the screen is not a swipe)\r\n\r\n```javascript\r\nswipeMaxDistance_px: 160,\r\n```\r\n\r\nMaximum dragged distance to still be a swipe.\r\n\r\n```javascript\r\nswipeMinDisplacement_px: 8,\r\n```\r\n\r\nSpeed being distance / time, define the minimal distance covered by the first drag to consider as swipe. It's not\r\nretina friendly. In fact, it's not multi-DPI friendly, and needs improvement!\r\n\r\n```javascript\r\ntapMaxDuration_ms: 150,\r\n```\r\n\r\nIf the pointer goes down without moving / releasing for longer than this, it's a tip.\r\n\r\n```javascript\r\nuseBorisSmusPointersPolyfill: false,\r\n```\r\n\r\nUses Boris Smus [\"pointers.js\"](https://github.com/borismus/pointer.js) polyfill. Defaults to false. BE CAREFUL: you have to modify the library, to deactivate the Gestures management, fully not compatible with TipTap.\r\n\r\n<a name=\"3\" />\r\n```javascript\r\nuseTipPrefixes: false,\r\n```\r\n\r\nInclude or not the \"tip\" prefixes in combos for matching: \"tip-tap\" or just \"tap\". DEFAULTS TO FALSE because,\r\nin fact, in a serious application, using some finished state system, it doesn't really make sense,\r\nand just makes combos definitions counter-intuitive.\r\n\r\n\r\n## Setting a callback\r\n\r\n#### With jQuery\r\n\r\n```javascript\r\n$(<targets filter>).jTipTap(\"on\", <combo>[, <filter>], callback[, bound object])\r\n```\r\n- _targets filter_: any CSS path as used in jQuery\r\n- _\"on\"_: means we created a new TipTap \"event\". \"off\" doesn't exist yet.\r\n- _combo_: any string defining a valid combo (syntax validation is, let's be fair, inexistant): \"tap\",\r\n\"tip-tap\", \"tap2>tap3\", \"tip2-swipe_r\", \"press|tip\", \"tip*-dragStart\", etc.\r\n- _filter_ (optional): again, any CSS/jQuery valid filter, to define which objects will really receive be targeted by the\r\ncall. This is very like event delegation: \".classname\", \"not:input\", etc.\r\n- _callback_: a function receiving an Action object as parameter\r\n- _bound object_ (optional): if specified, the **this** in the callback will be valued to this object. Equivalent of $.bind or _.bind\r\n\r\n#### Without jQuery\r\n\r\nThe lib has been made usable without jQuery. The biggest (only?) drawback is the fact that the \"filter\" option for delegation only accepts classname. Beware: it's \"_classname_\", and not \"_.classname_\"!\r\n\r\nThe syntax is then a bit different:\r\n``` javascript\r\n\tTipTap.on(\r\n\t\t<DOM element|DOM elements list>,\r\n\t\t[\r\n\t\t\t{\r\n\t\t\t\tcombo:    '<combo>',\r\n\t\t\t\tfilter:   \"<filter>\",\r\n\t\t\t\tcallback: function (action) {\r\n\t\t\t\t  // do your stuff here\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t],\r\n\t\t<bound object>);\r\n```\r\n\r\n- DOM element: as retrieved by document.getElementById()\r\n- DOM elements list: untested. Should allow to work on list of DOM elements sent back by getElementByClassName, getElementByTagName, querySelectorAll, etc. **FULLY NOT TESTED**\r\n- _combo_: as in jQuery version. Any string defining a valid combo.\r\n- _filter_: only a string being a classname. Does NOT include the \".\" in opposition to jQuery (because there, it's\r\na CSS syntax...\r\n- _callback_: as in jQuery version, callback receiving the Action as parameter\r\n- _bound object_: as in jQuery version, will be the _this_ in the callback\r\n\r\n\r\n### A simple callback on an element\r\n\r\nSetting up a callback is a simple as this:\r\n```javascript\r\n$('#myID').jTipTap('on', 'tap',\r\n           function (action) {\r\n           \talert('You tapped me!');\r\n           });\r\n```\r\n\r\nAs you could guess, this will pop an alert when you **tap** the element of id **myID**. Defining more complex gestures and combos is as simple as this, and this is why this library was made for.\r\n\r\n### A callback delegated to sub-elements\r\n\r\nThis is hardly harder:\r\n```javascript\r\n$('#myID').jTipTap('on',\"tap\", \".sub\"\r\n           function (action) {\r\n           \talert(\"You tapped element: \" + action.getPointer(0).$target[0].id);\r\n           });\r\n```\r\nThe third (optional) parameter is any valid jQuery filter (since all tests are made using jQuery **is()**), allowing some quite\r\nrich way of choosing which elements to pick, including usage of **not:**, elements names, classes, ids...\r\nThe method **getPointer()** from parameter **action** retrieves the pointer by the given number FROM THE LAST GESTURE.\r\nThis is important to know that we can get such informations only for the last gesture done. We could keep track of all the\r\ngestures which made the combo, but I didn't have the usage yet, so it is this way for now.\r\n\r\n### The Pointer object\r\n\r\nThe Pointer structure is quite simple, the four more important properties for the user being:\r\n```javascript\r\nidentifier\r\n```\r\nThe pointer identifier. Either given by the system for Touch devices, or created by TipTap library for the Mouse (but \r\nmeaningless in this case except for internal stuff)\r\n\r\n```javascript\r\n$target\r\n```\r\nThe jQuery object wrapping the DOM element which received the gesture\r\n\r\n```javascript\r\npageX\r\n```\r\nThe pageX (like in DOM) where the gesture happened\r\n\r\n```javascript\r\npageY\r\n```\r\nThe pageY (like in DOM) where the gesture happened\r\n\r\n## The included demo\r\n\r\n### Dependencies\r\n\r\nTo run the demo, you need to have a /libs/ folder containing the following files:\r\n- jquery-1.8.1.min.js\r\n- lodash.min.js\r\n- signals.min.js\r\nThey were not included in this repo because I think it's not the way to do.\r\n\r\n### Content\r\n\r\nThe small demo shows the basics of TipTap, like attaching some callbacks to a main element, and to its not yet existing\r\nchildren, pretty much like event delegation. Because the only events created are attached to the main container, no need\r\nto clean anything when removing these sub elements. It also shows some small tips, like using\r\n**tip\\*-tip\\+\\|tip\\*-press\\+** and **tip\\+\\|dragStart\\+** to deal with highlighting the selected image correctly (only\r\non tip or dragStart (in case the user moves the finger too fast for a **tip**), while the recording of the finger must \r\nhappen during tip or press (in case of fast drag start, again). If highlighting was set for **press** for example, a double\r\ntap would flash the highlighting because of the two **press** events sent.\r\n\r\n### Actions\r\n- tap the background to pop new images\r\n- press+drag or tip+drag (press+drag means you touch the screen (click mouse) and move right away, tip means you wait till the image border gets highlighted and shadow shows up) to move the image. On iPad, you can use your ten fingers and your nose to move up to 11 at a time (device limit)\r\n- with two or more fingers, you can zoom + rotate the pictures (however, as stated, this is not yet connected to decent usable system, it's only visual)\r\n- double tap an image to zoom by 1.1\r\n- triple tap an image to dezoom by 1.1\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Tiptap","tagline":"Javascript library to ease mouse and touch gestures management."}